# Data Structures

Prefetcher is a caching mechanism that tries to figure out what data is needed in advance and prefetch it. By creating a predictable data access pattern, we can help the prefetcher to work more efficiently. The prefetcher brings in 64 bytes at a type regardless of the size of the actual data being read. Therefore, array - data structure that stores data contiguously in memory - helps the prefetcher to be more efficient in caching the relevant data.

TLB (Translation Lookaside Buffer cache) is the caching system that converts virtual memory addresses to physical addresses in RAM. If the data requested is not found on the TLB, it further adds on to the latency and slows down the program.
There should be some consistency in which semantics to use when working with data. When working with the reference types (arrays, slices etc.) and built-in data types (numbers, strings, and bools), use the value semantics to move them around.

## Array

```go
var fruits [5]string
// String is a two-word data structure and each word is 4 bytes in size.
fruits[0] = "Apple"
fruits[1] = "Orange"
fruits[2] = "Banana"
fruits[3] = "Grape"
fruits[4] = "Plum"

// this loop is a value semantics where we're creating our own copy of the array to assign fruit its value
for i, fruit := range fruits {
    // here we're modifying the original array; so fruits[1] which was initially "Orange" now becomes "Seabuckthorn"
    fruits[1] = "Seabuckthorn"
    if i == 1 {
        // fruit is the copy of the value at the first index of the copied array of fruits
        // so, the copied arrays first index is still storing "Orange" currently
        fmt.Printf("%s\n", fruit) // Orange
        // but if we check the original array's first index, it's now "Seabuckthorn
        fmt.Printf("%s\n", fruits[1])
    }
}

// let's check again
// The original array is indeed modified
fmt.Printf("%s\n", fruits[1]) // Seabuckthorn

// the equivalent, but pointer/reference semantics would be the following
for i := range fruits {
    fruits[1] = "Kiwi"
    if i == 1 {
        fmt.Printf("%s\n", fruits[i]) // Kiwi
    }
}
```

## Slices

Slice is the most important data structure in Go as it provides mechanical sympathy like array but is also dynamic in nature. It's a three-word data structure. First word points to the array, and the second word holds the length, while the third word contains the capacity (total number of available spots).
You have to be very careful with read and write operations on the copies of reference types such as slices because Go uses reference semantics in those operations. If you're working with the copy of a slice, that copy only holds the copy of the pointer to the original slice.

```go
    // make a slice with a length of 5 elements and a capacity of 8
    fruits := make([]string, 5, 8)
    fruits[0] = "Apple"
    fruits[1] = "Orange"
    fruits[2] = "Banana"
    fruits[3] = "Grape"
    fruits[4] = "Plum"

    fmt.Printf("%s", fruits[5]) // panic: runtime error: index out of range [5] with length 5
```

An empty slice and the absence of a slice (nil slice) are represented differently as follows:

```go
    // empty slice has a pointer pointing at the empty struct
    emptySlice := []string{}

    // empty struct is a zero allocation type and it's embedded into the runtime
    // you can think of the empty struct almost as a global variable that has one address
    // all the empty structs would be pointing to that address
    emptyStruct = struct{}{} 
    //you can also declare it as follows: 
    var emptyStruct1 struct{}

    // nil slice of strings (meaning there's no pointer in this slice data structure currently)
    var nilSlice []string
    // when you call append on a nil slice, the append function gets its own copy of the slice data structure (3-word: 1. pointer; 2. length; 3. capacity)
    // it checks the length and the capacity of the slice which are both zero currently,
    // and creates a new slice with the appended element and returns the slice
    // this is called the value semantic mutation api and it's the safest way to mutate built-in types & reference types
    nilSlice = append(nilSlice, "Hello")

    // when append is called the second time, it checks the length and the capacity again, and if they're equal
    // it creates a new slice with the capacity twice as big and includes the original elements plus the appended element and returns the slice
    nilSlice = append(nilSlice, "Second Hello")

    // the following code may create MEMORY LEAK because nilSlice is still holding the pointer to previous array we might not need later
    anotherSlice = append(nilSlice, "Third Hello")

    // if you know the size of the slice, state that with the capacity up front and append the values to it more efficiently
    slice100kCap := make([]string, 0, 1e5)

    // or you can create a slice with the desired length and directly access each element with its index to update it
    slice100kLength := make([]string, 1e5)
```
