# Data Structures

Prefetcher is a caching mechanism that tries to figure out what data is needed in advance and prefetch it. By creating a predictable data access pattern, we can help the prefetcher to work more efficiently. The prefetcher brings in 64 bytes at a type regardless of the size of the actual data being read. Therefore, array - data structure that stores data contiguously in memory - helps the prefetcher to be more efficient in caching the relevant data.

TLB (Translation Lookaside Buffer cache) is the caching system that converts virtual memory addresses to physical addresses in RAM. If the data requested is not found on the TLB, it further adds on to the latency and slows down the program.
There should be some consistency in which semantics to use when working with data. When working with the reference types (arrays, slices etc.) and built-in data types (numbers, strings, and bools), use the value semantics to move them around.

## Array

```go
var fruits [5]string
// String is a two-word data structure and each word is 4 bytes in size.
fruits[0] = "Apple"
fruits[1] = "Orange"
fruits[2] = "Banana"
fruits[3] = "Grape"
fruits[4] = "Plum"

// this loop is a value semantics where we're creating our own copy of the array to assign fruit its value
for i, fruit := range fruits {
    // here we're modifying the original array; so fruits[1] which was initially "Orange" now becomes "Seabuckthorn"
    fruits[1] = "Seabuckthorn"
    if i == 1 {
        // fruit is the copy of the value at the first index of the copied array of fruits
        // so, the copied arrays first index is still storing "Orange" currently
        fmt.Printf("%s\n", fruit) // Orange
        // but if we check the original array's first index, it's now "Seabuckthorn
        fmt.Printf("%s\n", fruits[1])
    }
}

// let's check again
// The original array is indeed modified
fmt.Printf("%s\n", fruits[1]) // Seabuckthorn

// the equivalent, but pointer/reference semantics would be the following
for i := range fruits {
    fruits[1] = "Kiwi"
    if i == 1 {
        fmt.Printf("%s\n", fruits[i]) // Kiwi
    }
}
```

## Slices

Slice is the most important data structure in Go as it provides mechanical sympathy like array but is also dynamic in nature. It's a three-word data structure. First word points to the array, and the second word holds the length, while the third word contains the capacity (total number of available spots).
You have to be very careful with read and write operations on the copies of reference types such as slices because Go uses reference semantics in those operations. If you're working with the copy of a slice, that copy only holds the copy of the pointer to the original slice.

```go
    // make a slice with a length of 5 elements and a capacity of 8
    fruits := make([]string, 5, 8)
    fruits[0] = "Apple"
    fruits[1] = "Orange"
    fruits[2] = "Banana"
    fruits[3] = "Grape"
    fruits[4] = "Plum"

    fmt.Printf("%s", fruits[5]) // panic: runtime error: index out of range [5] with length 5


```
